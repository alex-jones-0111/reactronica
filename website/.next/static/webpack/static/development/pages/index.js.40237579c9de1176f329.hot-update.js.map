{"version":3,"file":"static/webpack/static/development/pages/index.js.40237579c9de1176f329.hot-update.js","sources":["webpack:///../dist/index.es.js"],"sourcesContent":["import React, { useEffect, useState, useRef, useContext } from 'react';\nimport PropTypes from 'prop-types';\n\nvar commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar StartAudioContext = createCommonjsModule(function (module) {\n/**\n *  StartAudioContext.js\n *  @author Yotam Mann\n *  @license http://opensource.org/licenses/MIT MIT License\n *  @copyright 2016 Yotam Mann\n */\n(function (root, factory) {\n\tif (module.exports) {\n        module.exports = factory();\n\t} else {\n\t\troot.StartAudioContext = factory();\n  }\n}(commonjsGlobal, function () {\n\n\t//TAP LISTENER/////////////////////////////////////////////////////////////\n\n\t/**\n\t * @class  Listens for non-dragging tap ends on the given element\n\t * @param {Element} element\n\t * @internal\n\t */\n\tvar TapListener = function(element, context){\n\n\t\tthis._dragged = false;\n\n\t\tthis._element = element;\n\n\t\tthis._bindedMove = this._moved.bind(this);\n\t\tthis._bindedEnd = this._ended.bind(this, context);\n\n\t\telement.addEventListener(\"touchstart\", this._bindedEnd);\n\t\telement.addEventListener(\"touchmove\", this._bindedMove);\n\t\telement.addEventListener(\"touchend\", this._bindedEnd);\n\t\telement.addEventListener(\"mouseup\", this._bindedEnd);\n\t};\n\n\t/**\n\t * drag move event\n\t */\n\tTapListener.prototype._moved = function(e){\n\t\tthis._dragged = true;\n\t};\n\n\t/**\n\t * tap ended listener\n\t */\n\tTapListener.prototype._ended = function(context){\n\t\tif (!this._dragged){\n\t\t\tstartContext(context);\n\t\t}\n\t\tthis._dragged = false;\n\t};\n\n\t/**\n\t * remove all the bound events\n\t */\n\tTapListener.prototype.dispose = function(){\n\t\tthis._element.removeEventListener(\"touchstart\", this._bindedEnd);\n\t\tthis._element.removeEventListener(\"touchmove\", this._bindedMove);\n\t\tthis._element.removeEventListener(\"touchend\", this._bindedEnd);\n\t\tthis._element.removeEventListener(\"mouseup\", this._bindedEnd);\n\t\tthis._bindedMove = null;\n\t\tthis._bindedEnd = null;\n\t\tthis._element = null;\n\t};\n\n\t//END TAP LISTENER/////////////////////////////////////////////////////////\n\n\t/**\n\t * Plays a silent sound and also invoke the \"resume\" method\n\t * @param {AudioContext} context\n\t * @private\n\t */\n\tfunction startContext(context){\n\t\t// this accomplishes the iOS specific requirement\n\t\tvar buffer = context.createBuffer(1, 1, context.sampleRate);\n\t\tvar source = context.createBufferSource();\n\t\tsource.buffer = buffer;\n\t\tsource.connect(context.destination);\n\t\tsource.start(0);\n\n\t\t// resume the audio context\n\t\tif (context.resume){\n\t\t\tcontext.resume();\n\t\t}\n\t}\n\n\t/**\n\t * Returns true if the audio context is started\n\t * @param  {AudioContext}  context\n\t * @return {Boolean}\n\t * @private\n\t */\n\tfunction isStarted(context){\n\t\t return context.state === \"running\"\n\t}\n\n\t/**\n\t * Invokes the callback as soon as the AudioContext\n\t * is started\n\t * @param  {AudioContext}   context\n\t * @param  {Function} callback\n\t */\n\tfunction onStarted(context, callback){\n\n\t\tfunction checkLoop(){\n\t\t\tif (isStarted(context)){\n\t\t\t\tcallback();\n\t\t\t} else {\n\t\t\t\trequestAnimationFrame(checkLoop);\n\t\t\t\tif (context.resume){\n\t\t\t\t\tcontext.resume();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (isStarted(context)){\n\t\t\tcallback();\n\t\t} else {\n\t\t\tcheckLoop();\n\t\t}\n\t}\n\n\t/**\n\t * Add a tap listener to the audio context\n\t * @param  {Array|Element|String|jQuery} element\n\t * @param {Array} tapListeners\n\t */\n\tfunction bindTapListener(element, tapListeners, context){\n\t\tif (Array.isArray(element) || (NodeList && element instanceof NodeList)){\n\t\t\tfor (var i = 0; i < element.length; i++){\n\t\t\t\tbindTapListener(element[i], tapListeners, context);\n\t\t\t}\n\t\t} else if (typeof element === \"string\"){\n\t\t\tbindTapListener(document.querySelectorAll(element), tapListeners, context);\n\t\t} else if (element.jquery && typeof element.toArray === \"function\"){\n\t\t\tbindTapListener(element.toArray(), tapListeners, context);\n\t\t} else if (Element && element instanceof Element){\n\t\t\t//if it's an element, create a TapListener\n\t\t\tvar tap = new TapListener(element, context);\n\t\t\ttapListeners.push(tap);\n\t\t} \n\t}\n\n\t/**\n\t * @param {AudioContext} context The AudioContext to start.\n\t * @param {Array|String|Element|jQuery=} elements For iOS, the list of elements\n\t *                                               to bind tap event listeners\n\t *                                               which will start the AudioContext. If\n\t *                                               no elements are given, it will bind\n\t *                                               to the document.body.\n\t * @param {Function=} callback The callback to invoke when the AudioContext is started.\n\t * @return {Promise} The promise is invoked when the AudioContext\n\t *                       is started.\n\t */\n\tfunction StartAudioContext(context, elements, callback){\n\n\t\t//the promise is invoked when the AudioContext is started\n\t\tvar promise = new Promise(function(success) {\n\t\t\tonStarted(context, success);\n\t\t});\n\n\t\t// The TapListeners bound to the elements\n\t\tvar tapListeners = [];\n\n\t\t// add all the tap listeners\n\t\tif (!elements){\n\t\t\telements = document.body;\n\t\t}\n\t\tbindTapListener(elements, tapListeners, context);\n\n\t\t//dispose all these tap listeners when the context is started\n\t\tpromise.then(function(){\n\t\t\tfor (var i = 0; i < tapListeners.length; i++){\n\t\t\t\ttapListeners[i].dispose();\n\t\t\t}\n\t\t\ttapListeners = null;\n\n\t\t\tif (callback){\n\t\t\t\tcallback();\n\t\t\t}\n\t\t});\n\n\t\treturn promise\n\t}\n\n\treturn StartAudioContext\n}));\n});\n\n// import Tone from 'tone';\n\nvar tone = void 0;\n\nif (typeof window !== 'undefined') {\n  tone = require('Tone');\n} else {\n  tone = null;\n}\n\nvar Tone = tone;\n\nvar SongContext = React.createContext();\n\nvar Song = function Song(_ref) {\n  var _ref$isPlaying = _ref.isPlaying,\n      isPlaying = _ref$isPlaying === undefined ? false : _ref$isPlaying,\n      _ref$tempo = _ref.tempo,\n      tempo = _ref$tempo === undefined ? 90 : _ref$tempo,\n      _ref$swing = _ref.swing,\n      swing = _ref$swing === undefined ? 0 : _ref$swing,\n      _ref$swingSubdivision = _ref.swingSubdivision,\n      swingSubdivision = _ref$swingSubdivision === undefined ? '8n' : _ref$swingSubdivision,\n      children = _ref.children;\n\n  useEffect(function () {\n    Tone.Transport.bpm.value = tempo;\n    Tone.Transport.swing = swing;\n    Tone.Transport.swingSubdivision = swingSubdivision;\n  }, [tempo, swing, swingSubdivision]);\n\n  useEffect(function () {\n    if (isPlaying) {\n      // Hack to get Tone to NOT use same settings from another instance\n      Tone.Transport.bpm.value = tempo;\n      Tone.Transport.swing = swing;\n      Tone.Transport.swingSubdivision = swingSubdivision;\n\n      Tone.Transport.start();\n\n      // iOS Web Audio API requires this library.\n      StartAudioContext(Tone.context);\n    } else {\n      Tone.Transport.stop();\n    }\n  }, [isPlaying]);\n\n  if (typeof window === 'undefined') {\n    return null;\n  }\n\n  return React.createElement(\n    SongContext.Provider,\n    {\n      value: {\n        // NOTE: Not sure what tracks are for...\n        // tracks,\n        // updateTracks: this.updateTracks,\n        // instruments: [],\n        isPlaying: isPlaying\n      }\n    },\n    children\n  );\n};\n\nSong.propTypes = {\n  isPlaying: PropTypes.bool,\n  tempo: PropTypes.number,\n  swing: PropTypes.number,\n  swingSubdivision: PropTypes.oneOf(['8n']),\n  children: PropTypes.node\n};\n\n// NOTE: Is constants the best name for this file?\n\nvar effects = [{ id: 'feedbackDelay', name: 'Feedback delay' }, { id: 'distortion', name: 'Distortion' }, { id: 'freeverb', name: 'Freeverb' }, { id: 'panVol', name: 'Volume/Pan' }];\n\nvar instruments = [{ id: 'polySynth', name: 'Poly synth' }, { id: 'duoSynth', name: 'Duo synth' }, { id: 'sampler', name: 'Sampler' }];\n\nvar constants = {\n  effects: effects,\n  instruments: instruments\n};\n\nvar NoteType = PropTypes.shape({\n  name: PropTypes.string.isRequired,\n  pitch: PropTypes.string,\n  octave: PropTypes.number,\n  accidental: PropTypes.string,\n  midi: PropTypes.number\n});\n\nvar StepNoteType = PropTypes.shape({\n  note: PropTypes.oneOfType([NoteType, PropTypes.string]),\n  position: PropTypes.number,\n  duration: PropTypes.number,\n  velocity: PropTypes.number\n});\n\nvar StepType = PropTypes.oneOfType([StepNoteType, PropTypes.arrayOf(StepNoteType), PropTypes.string]);\n\nvar InstrumentTypes = PropTypes.oneOf(instruments.map(function (effect) {\n  return effect.id;\n}));\n\nvar EffectTypes = PropTypes.oneOf(effects.map(function (effect) {\n  return effect.id;\n}));\n\nfunction buildSequencerStep(step, i) {\n  if (typeof step === 'string') {\n    return {\n      notes: [{\n        note: step\n      }],\n      index: i\n    };\n  } else if (step && step.note) {\n    return {\n      notes: [{\n        note: step.note,\n        duration: step.duration,\n        velocity: step.velocity\n      }],\n      index: i\n    };\n  } else if (Array.isArray(step)) {\n    return {\n      notes: step.map(function (s) {\n        if (typeof s === 'string') {\n          return {\n            note: s\n          };\n        }\n\n        return s;\n      }),\n      index: i\n    };\n  }\n\n  return {\n    notes: [],\n    index: i\n  };\n}\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\nvar TrackContext = React.createContext();\n\nvar TrackConsumer = function TrackConsumer(_ref) {\n  var isPlaying = _ref.isPlaying,\n      steps = _ref.steps,\n      _ref$volume = _ref.volume,\n      volume = _ref$volume === undefined ? 0 : _ref$volume,\n      _ref$pan = _ref.pan,\n      pan = _ref$pan === undefined ? 0 : _ref$pan,\n      _ref$subdivision = _ref.subdivision,\n      subdivision = _ref$subdivision === undefined ? '4n' : _ref$subdivision,\n      _ref$effects = _ref.effects,\n      effects = _ref$effects === undefined ? [] : _ref$effects,\n      children = _ref.children,\n      onStepPlay = _ref.onStepPlay;\n\n  var _useState = useState([]),\n      _useState2 = slicedToArray(_useState, 2),\n      effectsChain = _useState2[0],\n      setEffectsChain = _useState2[1];\n\n  var _useState3 = useState([]),\n      _useState4 = slicedToArray(_useState3, 2),\n      instruments = _useState4[0],\n      setInstruments = _useState4[1];\n\n  var sequencer = useRef();\n  var instrumentsRef = useRef(instruments);\n\n  useEffect(function () {\n    instrumentsRef.current = instruments;\n  }, [instruments]);\n\n  /*\n  Tone.Sequence can't easily play chords. By default, arrays within steps are flattened out and subdivided. However an array of notes is our preferred way of representing chords. To get around this, buildSequencerStep() will transform notes and put them in a notes field as an array. We can then loop through and run triggerAttackRelease() to play the note/s.\n  */\n  var sequencerSteps = steps.map(buildSequencerStep);\n\n  useEffect(function () {\n    // -------------------------------------------------------------------------\n    // STEPS\n    // -------------------------------------------------------------------------\n\n    // Start/Stop sequencer!\n    if (isPlaying) {\n      sequencer.current = new Tone.Sequence(function (time, step) {\n        step.notes.forEach(function (note) {\n          instrumentsRef.current.map(function (instrument) {\n            instrument.triggerAttackRelease(note.note, note.duration, undefined, note.velocity);\n          });\n        });\n\n        if (typeof onStepPlay === 'function') {\n          onStepPlay(step, step.index);\n        }\n      }, sequencerSteps, subdivision);\n\n      sequencer.current.start(0);\n    } else {\n      if (sequencer.current) {\n        sequencer.current.stop();\n      }\n    }\n  }, [isPlaying]);\n\n  useEffect(function () {\n    if (sequencer.current) {\n      sequencer.current.removeAll();\n\n      sequencerSteps.forEach(function (note, i) {\n        sequencer.current.add(i, note);\n      });\n    }\n  }, [steps]);\n\n  useEffect(function () {\n    return function cleanup() {\n      if (sequencer.current) {\n        sequencer.current.dispose();\n      }\n    };\n  }, []);\n\n  var handleAddToEffectsChain = function handleAddToEffectsChain(effect) {\n    // console.log('<Track />', 'onAddToEffectsChain');\n\n    setEffectsChain(function (prevEffectsChain) {\n      return [effect].concat(toConsumableArray(prevEffectsChain));\n    });\n  };\n\n  var handleRemoveFromEffectsChain = function handleRemoveFromEffectsChain(effect) {\n    // console.log('<Track />', 'onRemoveFromEffectsChain', effect);\n\n    setEffectsChain(function (prevEffectsChain) {\n      return prevEffectsChain.filter(function (e) {\n        return e.id !== effect.id;\n      });\n    });\n  };\n\n  var handleInstrumentsUpdate = function handleInstrumentsUpdate(newInstruments) {\n    setInstruments(newInstruments);\n  };\n\n  return React.createElement(\n    TrackContext.Provider,\n    {\n      value: {\n        effectsChain: effectsChain, // Used by Instrument\n        onInstrumentsUpdate: handleInstrumentsUpdate,\n        onAddToEffectsChain: handleAddToEffectsChain,\n        onRemoveFromEffectsChain: handleRemoveFromEffectsChain,\n        pan: pan,\n        volume: volume\n      }\n    },\n    children,\n    effects\n  );\n};\n\nTrackConsumer.propTypes = {\n  // <Song /> props\n  isPlaying: PropTypes.bool,\n  // <Track /> props\n  steps: PropTypes.arrayOf(StepType),\n  volume: PropTypes.number,\n  pan: PropTypes.number,\n  subdivision: PropTypes.string, // react-music = resolution\n  effects: PropTypes.arrayOf(PropTypes.element), // TODO: Consider accepting Tone effects signals\n  onStepPlay: PropTypes.func\n};\n\nvar Track = function Track(props) {\n  var value = React.useContext(SongContext);\n\n  return React.createElement(TrackConsumer, _extends({}, value, props));\n};\n\nfunction usePrevious(value) {\n  // The ref object is a generic container whose current property is mutable ...\n  // ... and can hold any value, similar to an instance property on a class\n  var ref = useRef();\n\n  // Store current value in ref\n  useEffect(function () {\n    ref.current = value;\n  }, [value]); // Only re-run if value changes\n\n  // Return previous value (happens before update in useEffect above)\n  return ref.current;\n}\n\nvar InstrumentConsumer = function InstrumentConsumer(_ref) {\n  var _ref$type = _ref.type,\n      type = _ref$type === undefined ? 'polySynth' : _ref$type,\n      _ref$options = _ref.options,\n      options = _ref$options === undefined ? {\n    polyphony: 4,\n    oscillator: {\n      partials: [0, 2, 3, 4]\n    }\n  } : _ref$options,\n      _ref$notes = _ref.notes,\n      notes = _ref$notes === undefined ? [] : _ref$notes,\n      samples = _ref.samples,\n      volume = _ref.volume,\n      pan = _ref.pan,\n      effectsChain = _ref.effectsChain,\n      onInstrumentsUpdate = _ref.onInstrumentsUpdate;\n\n  var synth = useRef();\n  var trackChannelBase = useRef(new Tone.PanVol(pan, volume));\n  var prevNotes = usePrevious(notes);\n\n  // -------------------------------------------------------------------------\n  // INSTRUMENT TYPE\n  // -------------------------------------------------------------------------\n\n  useEffect(function () {\n    var _synth$current;\n\n    // console.log(type);\n\n    // if (synth.current) {\n    //   synth.current.disconnect();\n    // }\n\n    if (type === 'polySynth') {\n      synth.current = new Tone.PolySynth(options.polyphony, Tone.Synth, options);\n    } else if (type === 'duoSynth') {\n      synth.current = new Tone.DuoSynth(options);\n    } else if (type === 'sampler') {\n      synth.current = new Tone.Sampler(samples);\n    }\n\n    // trackChannelBase.current = new Tone.PanVol(pan, volume);\n    // synth.current.chain(trackChannelBase.current, Tone.Master);\n\n    // synth.current.disconnect();\n    (_synth$current = synth.current).chain.apply(_synth$current, toConsumableArray(effectsChain).concat([trackChannelBase.current, Tone.Master]));\n\n    // Add this Instrument to Track Context\n    onInstrumentsUpdate([synth.current]);\n\n    return function cleanup() {\n      if (synth.current) ;\n    };\n  }, [type]);\n\n  // -------------------------------------------------------------------------\n  // VOLUME / PAN\n  // -------------------------------------------------------------------------\n\n  useEffect(function () {\n    trackChannelBase.current.volume.value = volume;\n  }, [volume]);\n\n  useEffect(function () {\n    trackChannelBase.current.pan.value = pan;\n  }, [pan]);\n\n  // -------------------------------------------------------------------------\n  // NOTES\n  // -------------------------------------------------------------------------\n\n  useEffect(function () {\n    // Loop through all current notes\n    notes.forEach(function (note) {\n      // Check if note is playing\n      var isPlaying = prevNotes.filter(function (n) {\n        return n.name === note.name;\n      }).length > 0;\n\n      // Only play note is it isn't already playing\n      if (!isPlaying) {\n        synth.current.triggerAttack(note.name);\n      }\n    });\n\n    // Loop through all previous notes\n    prevNotes && prevNotes.forEach(function (note) {\n      // Check if note is still playing\n      var isPlaying = notes.filter(function (n) {\n        return n.name === note.name;\n      }).length > 0;\n\n      if (!isPlaying) {\n        synth.current.triggerRelease(note.name);\n      }\n    });\n  }, [notes]);\n\n  // -------------------------------------------------------------------------\n  // EFFECTS CHAIN\n  // -------------------------------------------------------------------------\n\n  useEffect(function () {\n    var _synth$current2;\n\n    // console.log('<Instrument />', 'updateEffectsChain', effectsChain);\n\n    // trackChannelBase.current = new Tone.PanVol(pan, volume);\n\n    // NOTE: Using trackChannelBase causes effects to not turn off\n    synth.current.disconnect();\n    (_synth$current2 = synth.current).chain.apply(_synth$current2, toConsumableArray(effectsChain).concat([trackChannelBase.current, Tone.Master]));\n  }, [effectsChain]);\n\n  return null;\n};\n\nInstrumentConsumer.propTypes = {\n  // <Instrument /> Props\n  type: InstrumentTypes.isRequired,\n  options: PropTypes.object,\n  notes: PropTypes.arrayOf(NoteType), // Currently played notes.\n  samples: PropTypes.object,\n  trackChannel: PropTypes.object, // An instance of new this.Tone.PanVol()\n  // polyphony: PropTypes.number,\n  // <Track /> Props\n  volume: PropTypes.number,\n  pan: PropTypes.number,\n  effectsChain: PropTypes.array,\n  onInstrumentsUpdate: PropTypes.func\n};\n\nvar Instrument = function Instrument(props) {\n  var value = useContext(TrackContext);\n  // const { Tone } = useContext(SongContext);\n\n  if (typeof window === 'undefined') {\n    return null;\n  }\n\n  return React.createElement(InstrumentConsumer, _extends({}, value, props));\n};\n\nvar EffectConsumer = function EffectConsumer(_ref) {\n  var type = _ref.type,\n      id = _ref.id,\n      _ref$delayTime = _ref.delayTime,\n      delayTime = _ref$delayTime === undefined ? '8n' : _ref$delayTime,\n      _ref$feedback = _ref.feedback,\n      feedback = _ref$feedback === undefined ? 0.5 : _ref$feedback,\n      onAddToEffectsChain = _ref.onAddToEffectsChain,\n      onRemoveFromEffectsChain = _ref.onRemoveFromEffectsChain;\n\n  var effect = useRef();\n\n  useEffect(function () {\n    // console.log('<Effect /> mount');\n    // console.log(`id: ${id}`);\n\n    if (type === 'feedbackDelay') {\n      effect.current = new Tone.FeedbackDelay(delayTime, feedback);\n    } else if (type === 'distortion') {\n      effect.current = new Tone.Distortion(0.5);\n    } else if (type === 'freeverb') {\n      effect.current = new Tone.Freeverb();\n    } else if (type === 'panVol') {\n      effect.current = new Tone.PanVol();\n    }\n\n    effect.current.id = id;\n\n    // Update effects chain\n    // TODO: Work out which index to insert current this.effect\n    onAddToEffectsChain(effect.current);\n\n    return function () {\n      // console.log('<Effect /> unmount');\n      onRemoveFromEffectsChain(effect.current);\n    };\n  }, [type]);\n\n  useEffect(function () {\n    if (effect.current.feedback) {\n      effect.current.feedback.value = feedback;\n    }\n  }, [feedback]);\n\n  useEffect(function () {\n    if (effect.current.delayTime) {\n      effect.current.delayTime.value = delayTime;\n    }\n  }, [delayTime]);\n\n  return null;\n};\n\nEffectConsumer.propTypes = {\n  type: EffectTypes.isRequired,\n  id: PropTypes.string.isRequired,\n  options: PropTypes.object,\n  delayTime: PropTypes.string,\n  feedback: PropTypes.number,\n  onAddToEffectsChain: PropTypes.func,\n  onRemoveFromEffectsChain: PropTypes.func\n};\n\nvar Effect = function Effect(props) {\n  var value = useContext(TrackContext);\n\n  return React.createElement(EffectConsumer, _extends({}, value, props));\n};\n\nexport { Song, Track, Instrument, Effect, constants };\n//# sourceMappingURL=index.es.js.map\n"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;A","sourceRoot":""}